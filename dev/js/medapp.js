// Generated by CoffeeScript 1.6.3
(function() {
  var e, get_table_name, log, schema, self, table_exists, underscore, walk;

  self = this;

  log = function(mess) {
    return plv8.elog(NOTICE, JSON.stringify(mess));
  };

  e = function() {
    return plv8.execute.apply(plv8, arguments);
  };

  schema = 'fhir';

  underscore = function(str) {
    return str.replace(/([a-z\d])([A-Z]+)/g, "$1_$2").replace(/[-\s]+/g, "_").toLowerCase();
  };

  get_table_name = function(pth) {
    return plv8.execute('SELECT table_name($1)', [pth])[0].table_name;
  };

  table_exists = function(table_name) {
    var query, _base;
    query = "select table_name from information_schema.tables where table_schema = 'fhir'";
    (_base = self.sql).existed_tables || (_base.existed_tables = plv8.execute(query).map(function(i) {
      return i.table_name;
    }));
    return self.sql.existed_tables.indexOf(table_name) > -1;
  };

  walk = function(parents, name, obj, cb) {
    var key, new_parents, res, value, _results;
    res = cb.call(self, parents, name, obj);
    new_parents = parents.concat({
      name: name,
      obj: obj,
      meta: res
    });
    _results = [];
    for (key in obj) {
      value = obj[key];
      if (self.u.isObject(value)) {
        _results.push(self.sql.walk(new_parents, key, value, cb));
      } else if (Array.isArray(value)) {
        _results.push(value.map(function(v) {
          if (self.u.isObject(v)) {
            return self.sql.walk(new_parents, key, v, cb);
          }
        }));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  this.sql = {
    insert_resource: function(json) {
      var resource_name;
      resource_name = json.resourceType;
      schema = 'fhir.';
      return walk([], underscore(resource_name), json, function(parents, name, obj) {
        var attrs, pth, table_name;
        pth = parents.map(function(i) {
          return underscore(i.name);
        });
        pth.push(name);
        table_name = get_table_name(pth);
        if (table_exists(table_name)) {
          log("going insert into " + table_name);
          attrs = sql.collect_attributes(table_name, obj);
          attrs.id || (attrs.id = sql.uuid());
          sql.insert_record(schema + table_name, attrs);
          return attrs.id;
        } else {
          return log("Skip " + table_name);
        }
      });
    },
    insert_record: function(table_name, attrs) {
      return plv8.execute("insert into " + table_name + " (select * from json_populate_recordset(null::" + table_name + ", $1::json))", [JSON.stringify([attrs])]);
    },
    columns: function(table_name) {
      var _base;
      (_base = self.sql).columns_for || (_base.columns_for = self.sql.collect_columns());
      return self.sql.columns_for[table_name];
    },
    resources: function(version) {
      return e("select * from meta.resources where version = $1", [version]);
    },
    collect_columns: function() {
      var cols;
      cols = plv8.execute("select table_name, column_name from information_schema.columns where table_schema = 'fhir'", []);
      return cols.reduce((function(acc, col) {
        acc[col.table_name] = acc[col.table_name] || [];
        acc[col.table_name].push(col);
        return acc;
      }), {});
    },
    collect_attributes: function(table_name, obj) {
      var arr2lit, columns;
      columns = self.sql.columns(table_name);
      arr2lit = function(v) {
        v = v.map(function(i) {
          return "\"" + i + "\"";
        }).join(',');
        return "{" + v + "}";
      };
      return columns.reduce((function(acc, m) {
        var an, col_prefix, column_name, parts, v;
        column_name = m.column_name;
        an = u.camelize(column_name);
        v = obj[an];
        parts = column_name.match(/(.*)_reference/);
        if (parts) {
          col_prefix = parts[1];
          if (v = obj[u.camelize(col_prefix)]) {
            acc[column_name] = v.reference;
            acc["" + col_prefix + "_display"] = v.display;
          }
        } else if (v) {
          if (Array.isArray(v)) {
            acc[column_name] = arr2lit(v);
          } else {
            acc[m.column_name] = v;
          }
        }
        return acc;
      }), {});
    },
    uuid: function() {
      var sql;
      sql = 'select uuid_generate_v4() as uuid';
      return plv8.execute(sql)[0]['uuid'];
    },
    walk: function(parents, name, obj, cb) {
      var key, new_parents, res, value, _results;
      res = cb.call(self, parents, name, obj);
      new_parents = parents.concat({
        name: name,
        obj: obj,
        meta: res
      });
      _results = [];
      for (key in obj) {
        value = obj[key];
        if (self.u.isObject(value)) {
          _results.push(self.sql.walk(new_parents, key, value, cb));
        } else if (Array.isArray(value)) {
          _results.push(value.map(function(v) {
            if (self.u.isObject(v)) {
              return self.sql.walk(new_parents, key, v, cb);
            }
          }));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  this.u = {
    isObject: function(obj) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    },
    camelize: function(str) {
      return str.replace(/[-_\s]+(.)?/g, function(match, c) {
        if (c) {
          return c.toUpperCase();
        } else {
          return "";
        }
      });
    }
  };

}).call(this);
