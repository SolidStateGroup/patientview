// Generated by CoffeeScript 1.6.3
(function() {
  var clone, e, log, self, underscore;

  self = this;

  log = function(mess) {
    return plv8.elog(NOTICE, JSON.stringify(mess));
  };

  e = function() {
    return plv8.execute.apply(plv8, arguments);
  };

  underscore = function(str) {
    return str.replace(/([a-z\d])([A-Z]+)/g, "$1_$2").replace(/[-\s]+/g, "_").toLowerCase();
  };

  clone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
  };

  this.sql = {
    generate_schema: function(version) {
      var schema;
      schema = "fhirr";
      e("DROP SCHEMA IF EXISTS " + schema + " CASCADE;\nCREATE SCHEMA " + schema + ";");
      sql.generate_enums(schema, version);
      e("CREATE TABLE " + schema + ".resource (\n   id uuid PRIMARY KEY,\n   resource_type " + schema + ".\"ResourceType\" not null,\n   language varchar,\n   text xml,\n   text_status " + schema + ".\"NarrativeStatus\",\n   container_id uuid references " + schema + ".resource (id)\n);\n\nCREATE TABLE " + schema + ".resource_component (\n  id uuid PRIMARY KEY,\n  parent_id uuid references " + schema + ".resource_component (id),\n  resource_id uuid references " + schema + ".resource (id),\n  compontent_type varchar,\n  container_id uuid references " + schema + ".resource (id)\n);\n\nCREATE TABLE " + schema + ".resource_values (\n  id uuid PRIMARY KEY,\n  parent_id uuid references " + schema + ".resource_component (id),\n  resource_id uuid references " + schema + ".resource (id),\n  value_type varchar,\n  container_id uuid references " + schema + ".resource (id)\n);");
      sql.generate_datatypes_tables(schema, version);
      return;
      return sql.resources(version).forEach(function(r) {
        var attrs, components, table_name;
        table_name = underscore(r.type);
        components = sql.components(version, [r.type]);
        attrs = sql.mk_columns(components).join(',');
        attrs = attrs && (',' + attrs);
        e("CREATE TABLE " + schema + "." + table_name + " (\n resource_type " + schema + ".\"ResourceType\" default '" + r.type + "'\n " + attrs + "\n) INHERITS (" + schema + ".resource)");
        return components.forEach(function(a) {
          return sql.create_components_table(schema, version, a);
        });
      });
    },
    generate_enums: function(schema, version) {
      return e("SELECT * from meta.enums").forEach(function(en) {
        var opts;
        opts = en.options.map(function(i) {
          return "'" + i + "'";
        }).join(',');
        return e("CREATE TYPE " + schema + ".\"" + en["enum"] + "\"\nAS ENUM (" + opts + ")");
      });
    },
    tsort: function(deps) {
      var collect, deps_sutisfied;
      deps_sutisfied = function(deps, available) {
        return deps.filter((function(i) {
          return available.indexOf(i) === -1;
        })).length === 0;
      };
      collect = function(deps, resolved, guard) {
        var dp, tp;
        for (tp in deps) {
          dp = deps[tp];
          if (resolved.indexOf(tp) === -1 && deps_sutisfied(dp, resolved)) {
            resolved.push(tp);
          }
        }
        if (guard > 0) {
          return collect(deps, resolved, guard - 1);
        } else {
          return resolved;
        }
      };
      return collect(deps, [], 10);
    },
    generate_datatypes_tables: function(schema, version) {
      var deps, dts, types;
      deps = e("select datatype, array_agg(deps) as deps from meta.datatype_deps group by datatype").reduce((function(acc, i) {
        acc[i.datatype] = i.deps.filter(function(i) {
          return i;
        });
        return acc;
      }), {});
      types = sql.tsort(deps);
      types.forEach(function(tp) {
        return log("TODO: create " + tp);
      });
      return;
      dts = e("select de.datatype,\narray_agg(row_to_json(de.*)) attrs\nfrom meta.complex_datatypes cd\njoin meta.datatype_elements de on de.datatype =  cd.type\njoin meta.complex_datatypes cdd on cdd.type = de.type\nwhere cd.type not in ('Resource', 'BackboneElement', 'Extension', 'Narrative')\ngroup by datatype");
      return dts.forEach(function(dt) {
        log(dt.datatype);
        return log(dt.attrs.map(function(i) {
          return i.type;
        }));
      });
    },
    resources: function(version) {
      return e("select * from meta.resources where version = $1", [version]);
    },
    primitive_pg_types: {
      code: 'varchar',
      dateTime: 'timestamp',
      string: 'varchar',
      uri: 'varchar',
      datetime: 'timestamp',
      instant: 'timestamp',
      boolean: 'boolean',
      base64_binary: 'bytea',
      integer: 'integer',
      decimal: 'decimal',
      sampled_data_data_type: 'text',
      date: 'date',
      id: 'varchar',
      oid: 'varchar'
    },
    is_enum: function(type) {
      return e("select * from meta.enums where enum = $1", [type]).length > 0;
    },
    pg_type: function(type) {
      if (sql.is_enum(type)) {
        return "fhirr." + type;
      } else {
        return sql.primitive_pg_types[type];
      }
    },
    components: function(version, path) {
      var q;
      q = "select * from meta.components\nwhere array_to_string(parent_path,'.') = $1\norder by path";
      return sql.expand_polimorpic(e(q, [path.join('.')]));
    },
    name_from_path: function(path) {
      if (path) {
        return underscore(path[path.length - 1]);
      }
    },
    is_polimorphic: function(a) {
      var name;
      name = sql.name_from_path(a.path);
      return name.indexOf('[x]') > -1;
    },
    expand_polimorpic: function(attrs) {
      return attrs.reduce((function(acc, at) {
        var name;
        if (sql.is_polimorphic(at)) {
          name = sql.name_from_path(at.path).replace('[x]', '');
          at.type.map(function(tp) {
            var obj;
            obj = clone(at);
            obj.path[obj.path.length - 1] = "" + name + "_" + tp;
            obj.type = [tp];
            return acc.push(obj);
          });
        } else {
          acc.push(at);
        }
        return acc;
      }), []);
    },
    mk_columns: function(attrs) {
      return attrs.map(sql.mk_column).filter(function(i) {
        return i && i.replace(/(^\s*|\s*$)/, '');
      });
    },
    mk_column: function(a) {
      var name, type;
      name = underscore(a.path[a.path.length - 1]);
      type = sql.pg_type(a.type && a.type[0]);
      if (type) {
        return "\"" + name + "\" " + type;
      }
    },
    create_components_table: function(schema, version, comp) {
      var attrs, components, table_name;
      components = sql.components(version, comp.path);
      if (components.length > 0) {
        table_name = comp.path.map(underscore).join('_');
        attrs = sql.mk_columns(components).join(',');
        if (attrs) {
          e("CREATE TABLE " + schema + "." + table_name + " (\n  compontent_type varchar default '" + table_name + "',\n  " + attrs + "\n) INHERITS (" + schema + ".resource_component)");
        }
        return components.forEach(function(a) {
          return sql.create_components_table(schema, version, a);
        });
      }
    }
  };

}).call(this);
